# Learn_模块与包

## 模块

顶层代码组织单元，提供大粒度的封装和复用，通常每个模块对应一个源码文件（C或Cython）。



### 特点：

首次导入时（被编译成字节码，解释器为其创建模块实例，执行初始化语句，构建内部成员），普通语句直接执行，def，class保存在模块全局名字空间。

无论被导入多少次，每个模块在整个解释器进程内都仅有一个实例存在（第一次导入成功后，不再监测源文件是否有变动），重复导入仅引用已经存在的实例，不再进行初始化。

当模块作为主程序的入口时，会被赋予 “__ main __ ”，属性。



### 查看模块的相关信息：

```
模块名：
__dict__ :所有到属性及方法字典(包括类方法)

In [3]: os.__name__
Out[3]: 'os'

模块所在位置：
In [4]: os.__file__
Out[4]: '/home/t/anaconda3/lib/python3.6/os.py'


```



### 导入模块

 

导入步骤：

搜索目标文件（不要在同一路径下放置同名模块）

​	1.程序根目录

​	2.环境变量PYTHONPATH设定的目录列表

​	3.标准库目录

​	4.第三方扩展库等附加路径（site-specific，附加路径由site模块添加，除系统site-packages外，还包括用户相关目录），将所有要添加的路径保存在.path文本文件内。

x







按需编译目标模块

创建模块实例，执行初始化

将模块实例保存到全局列表

在当前名字空间建立引用







## 包











 记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。

   如果在结构中包是一个子包（比如这个例子中对于包:mod:sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块:mod:sound.filters.vocoder  要使用包:mod:sound.effects中的模块:mod:echo，你就要写成 from sound.effects import  echo。

```
from . import echo
from .. import formats
from ..filters import equalizer
```

 无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，一个Python应用程序的主模块，应当总是使用绝对路径引用。 

   包还提供一个额外的属性，:attr:__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的:file:__init__.py，你得在其他:file:__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。  

 这个功能并不常用，一般用来扩展包里面的模块。 



 包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。

 比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 