# Learn_模块与包

## 模块

顶层代码组织单元，提供大粒度的封装和复用，通常每个模块对应一个源码文件（C或Cython）。



### 特点：

​	首次导入时（被编译成字节码，解释器为其创建模块实例，执行初始化语句，构建内部成员），普通语句直接执行，def，class保存在模块全局名字空间。

​	无论被导入多少次，每个模块在整个解释器进程内都仅有一个实例存在（第一次导入成功后，不再监测源文件是否有变动），重复导入仅引用已经存在的实例，不再进行初始化。

​	当模块作为主程序的入口时，会被赋予 “__ main __ ”，属性。



### 查看模块的相关信息：

```
模块名：
__dict__ :所有到属性及方法字典(包括类方法)

In [3]: os.__name__
Out[3]: 'os'

模块所在位置：
In [4]: os.__file__
Out[4]: '/home/t/anaconda3/lib/python3.6/os.py'


```



### 导入模块

 

#### 导入步骤：

- 搜索目标文件（不要在同一路径下放置同名模块）

  搜索的路径为：

  	1.程序根目录
		
  	2.环境变量PYTHONPATH设定的目录列表
		
  	3.标准库目录
		
  	4.第三方扩展库等附加路径（site-specific，附加路径由site模块添加，除系统site-packages外，还包括		用户相关目录），将所有要添加的路径保存在.path文本文件内。放到site-packages目录中，由site管理（site会过滤掉配置文件中重复及不存在的路径）。

- 按需编译目标模块

  	生成字节码缓存，保存在__ pycache __文件夹中（可以使用—B参数阻止生成字节码文件），直接部署字节码文件（.pyc）可以作为一种代码的轻度保护。

- 创建模块实例，执行初始化

- 将模块实例保存到全局列表

- 在当前名字空间建立引用

  	当导入模块发生名字冲突时，使用as命名别名。





导入排列顺序：标准库——扩展库——当前程序模块。

定义__ all __  字段，用于导入* 的情况下，定于允许导入的所有模块功能列表（（应当尽量避免 * 号导入））





## 包

使用包用来组织模块（包能够隐藏内部文件到组织结构，而仅暴露必要到用户接口），仅导入包并不能直接访问其内部模块，须显示导入。



### 特点：

- __ init __ .py   :执行某些初始化操作（对外提供接口，解除用户对内部模块的直接依赖）

  	__ init __.py 文件在包或者其内部模块导入时执行，并且只执行一次。

  	定义 __ all __ 字段，用于定义在 * 号导入的情况下，需要导入的模块列表

- reload ，包内模块，不会再执行初始化文件，但重载包会。

- 包是运行期对象有自己到名字空间

- 仅导入包不能直接访问其内部模块，要使用包内部模块需要显示导入。

- 可以在包内创建__ main __ .py 文件，作为直接执行包的入口





### 相对导入：

​	在包内使用import方式导入模块，由于import会严格的按照搜索路径进行查找，且搜索路径不包括包目录本身，会导致在包内访问同级模块时，发生找不到文件到情况，于是引入相对导入。

from  [packageName]  import [models]

from  . [packageName]  import [models]  //代表从当前路径导入包

from  .. [packageName]  import [models]  //代表从当前路径的上一级目录导入包（一个.表示一级目录）



注：

- 相对导入只支持 from 语句。

- 	当相同名字到模块和包出现在同一路径下时，将按照如下路径进行匹配：

  ​		1.如果包有初始化文件（__ init __ .py ）则优先导入包

  ​		2.没有初始化文件则.py .pyc 模块优先。

- 当包内的模块文件过多时，可建立自包分组维护。







 使用from Package import specific_submodule是推荐的方法。除非是要导入的子模块有可能和其他包的子模块重名。

  如果在结构中包是一个子包（比如这个例子中对于包:mod:sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块:mod:sound.filters.vocoder  要使用包:mod:sound.effects中的模块:mod:echo，你就要写成 from sound.effects import  echo。

```
from . import echo
from .. import formats
from ..filters import equalizer
```

 无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，一个Python应用程序的主模块，应当总是使用绝对路径引用。 

   包还提供一个额外的属性，:attr:__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的:file:__init__.py，你得在其他:file:__init__.py被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。  

 这个功能并不常用，一般用来扩展包里面的模块。 



 包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。

 比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 